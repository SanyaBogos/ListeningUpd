/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.5.0.0 (NJsonSchema v10.1.15.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class CrosswordClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getCrosswords(query: CrosswordQueryViewModel): Observable<PagedDataViewModelOfCrosswordDescriptionDto> {
        let url_ = this.baseUrl + "/api/Crossword/queried";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrosswords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrosswords(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataViewModelOfCrosswordDescriptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataViewModelOfCrosswordDescriptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrosswords(response: HttpResponseBase): Observable<PagedDataViewModelOfCrosswordDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataViewModelOfCrosswordDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataViewModelOfCrosswordDescriptionDto>(<any>null);
    }

    getTextsEnhanced(query: AdminCrosswordQueryViewModel): Observable<PagedDataViewModelOfCrosswordDescriptionEnhancedDto> {
        let url_ = this.baseUrl + "/api/Crossword/queriedEnhanced";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTextsEnhanced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTextsEnhanced(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataViewModelOfCrosswordDescriptionEnhancedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataViewModelOfCrosswordDescriptionEnhancedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTextsEnhanced(response: HttpResponseBase): Observable<PagedDataViewModelOfCrosswordDescriptionEnhancedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataViewModelOfCrosswordDescriptionEnhancedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataViewModelOfCrosswordDescriptionEnhancedDto>(<any>null);
    }

    getCrossword(id: number): Observable<CrosswordWithAdminsListDto> {
        let url_ = this.baseUrl + "/api/Crossword/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrossword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrossword(<any>response_);
                } catch (e) {
                    return <Observable<CrosswordWithAdminsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CrosswordWithAdminsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrossword(response: HttpResponseBase): Observable<CrosswordWithAdminsListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CrosswordWithAdminsListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CrosswordWithAdminsListDto>(<any>null);
    }

    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Crossword/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    add(crosswordDto: CrosswordDto): Observable<LongIdsDto> {
        let url_ = this.baseUrl + "/api/Crossword/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(crosswordDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<LongIdsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LongIdsDto>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<LongIdsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LongIdsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LongIdsDto>(<any>null);
    }

    update(textDto: CrosswordDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Crossword/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(textDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    getBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Crossword/backup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    saveListeningAudio(name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/audio/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveListeningAudio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveListeningAudio(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveListeningAudio(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    saveListeningVideo(name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/lstng-vid/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveListeningVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveListeningVideo(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveListeningVideo(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    saveBlogVideo(name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/blog-vid/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBlogVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBlogVideo(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveBlogVideo(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    deleteBlogVideo(name: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/File/blog-vid/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBlogVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBlogVideo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBlogVideo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    saveSpecVideo(name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/spec-vid/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSpecVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSpecVideo(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveSpecVideo(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    saveStegPicture(name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/stegPic/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStegPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStegPicture(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveStegPicture(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    saveStegPictureAno(captcha: string | null, hash: string | null, name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/stegPic/{captcha}/{hash}/{name}";
        if (captcha === undefined || captcha === null)
            throw new Error("The parameter 'captcha' must be defined.");
        url_ = url_.replace("{captcha}", encodeURIComponent("" + captcha));
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStegPictureAno(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStegPictureAno(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveStegPictureAno(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    saveStegAudio(captcha: string | null, hash: string | null, name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/stegAud/{captcha}/{hash}?";
        if (captcha === undefined || captcha === null)
            throw new Error("The parameter 'captcha' must be defined.");
        url_ = url_.replace("{captcha}", encodeURIComponent("" + captcha));
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStegAudio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStegAudio(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveStegAudio(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    saveStegVideo(captcha: string | null, hash: string | null, name: string | null, file: FileParameter | null): Observable<FileNameViewModel> {
        let url_ = this.baseUrl + "/api/File/stegVid/{captcha}/{hash}?";
        if (captcha === undefined || captcha === null)
            throw new Error("The parameter 'captcha' must be defined.");
        url_ = url_.replace("{captcha}", encodeURIComponent("" + captcha));
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStegVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStegVideo(<any>response_);
                } catch (e) {
                    return <Observable<FileNameViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileNameViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveStegVideo(response: HttpResponseBase): Observable<FileNameViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileNameViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileNameViewModel>(<any>null);
    }

    getVideo(fileName: FileNameViewModel): Observable<VideoFileViewModel> {
        let url_ = this.baseUrl + "/api/File/video";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fileName);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideo(<any>response_);
                } catch (e) {
                    return <Observable<VideoFileViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<VideoFileViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetVideo(response: HttpResponseBase): Observable<VideoFileViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoFileViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VideoFileViewModel>(<any>null);
    }

    cutVideo(options: CuttingOptionsViewModel): Observable<VideoFileViewModel> {
        let url_ = this.baseUrl + "/api/File/cutVideo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCutVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCutVideo(<any>response_);
                } catch (e) {
                    return <Observable<VideoFileViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<VideoFileViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processCutVideo(response: HttpResponseBase): Observable<VideoFileViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoFileViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VideoFileViewModel>(<any>null);
    }

    getSpecVideo(type: string, author: string, innerType: string, name: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/specVideo/{type}/{author}/{name}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (author === undefined || author === null)
            throw new Error("The parameter 'author' must be defined.");
        url_ = url_.replace("{author}", encodeURIComponent("" + author));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (innerType === undefined || innerType === null)
            throw new Error("The parameter 'innerType' must be defined and cannot be null.");
        else
            url_ += "innerType=" + encodeURIComponent("" + innerType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecVideo(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpecVideo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class QuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getQuestions(query: QuestionQueryViewModel): Observable<PagedDataViewModelOfQuestionAndWordDescriptionDto> {
        let url_ = this.baseUrl + "/api/Question/queried";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestions(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataViewModelOfQuestionAndWordDescriptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataViewModelOfQuestionAndWordDescriptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestions(response: HttpResponseBase): Observable<PagedDataViewModelOfQuestionAndWordDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataViewModelOfQuestionAndWordDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataViewModelOfQuestionAndWordDescriptionDto>(<any>null);
    }

    getQuestion(id: number): Observable<QuestionAndWordDescriptionDto> {
        let url_ = this.baseUrl + "/api/Question/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestion(<any>response_);
                } catch (e) {
                    return <Observable<QuestionAndWordDescriptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionAndWordDescriptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestion(response: HttpResponseBase): Observable<QuestionAndWordDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionAndWordDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionAndWordDescriptionDto>(<any>null);
    }

    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Question/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    add(crosswordDto: CrosswordDto): Observable<LongIdsDto> {
        let url_ = this.baseUrl + "/api/Question/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(crosswordDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<LongIdsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LongIdsDto>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<LongIdsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LongIdsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LongIdsDto>(<any>null);
    }

    update(textDto: CrosswordDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Question/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(textDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    getBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Question/backup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ResultClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllUserTextResults(userId: number): Observable<ResultEnhancedDto> {
        let url_ = this.baseUrl + "/api/Result/allUserTextResults/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserTextResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserTextResults(<any>response_);
                } catch (e) {
                    return <Observable<ResultEnhancedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultEnhancedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserTextResults(response: HttpResponseBase): Observable<ResultEnhancedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultEnhancedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultEnhancedDto>(<any>null);
    }

    getDetailedResult(id: number): Observable<TextForGuessingDto> {
        let url_ = this.baseUrl + "/api/Result/detailedResult/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailedResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailedResult(<any>response_);
                } catch (e) {
                    return <Observable<TextForGuessingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TextForGuessingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailedResult(response: HttpResponseBase): Observable<TextForGuessingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TextForGuessingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TextForGuessingDto>(<any>null);
    }

    updateLeaveTime(result: ResultUpdateTimeDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Result/updateLeaveTime";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(result);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeaveTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeaveTime(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLeaveTime(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TextClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getTexts(query: TextQueryViewModel): Observable<PagedDataViewModelOfTextDescriptionDto> {
        let url_ = this.baseUrl + "/api/Text/queried";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataViewModelOfTextDescriptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataViewModelOfTextDescriptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTexts(response: HttpResponseBase): Observable<PagedDataViewModelOfTextDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataViewModelOfTextDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataViewModelOfTextDescriptionDto>(<any>null);
    }

    getTextsEnhanced(query: AdminTextQueryViewModel): Observable<PagedDataViewModelOfTextDescriptionEnhancedDto> {
        let url_ = this.baseUrl + "/api/Text/queriedEnhanced";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTextsEnhanced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTextsEnhanced(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataViewModelOfTextDescriptionEnhancedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataViewModelOfTextDescriptionEnhancedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTextsEnhanced(response: HttpResponseBase): Observable<PagedDataViewModelOfTextDescriptionEnhancedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataViewModelOfTextDescriptionEnhancedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataViewModelOfTextDescriptionEnhancedDto>(<any>null);
    }

    getText(textId: string | null): Observable<TextWithAdminsListDto> {
        let url_ = this.baseUrl + "/api/Text/{textId}";
        if (textId === undefined || textId === null)
            throw new Error("The parameter 'textId' must be defined.");
        url_ = url_.replace("{textId}", encodeURIComponent("" + textId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetText(<any>response_);
                } catch (e) {
                    return <Observable<TextWithAdminsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TextWithAdminsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetText(response: HttpResponseBase): Observable<TextWithAdminsListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TextWithAdminsListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TextWithAdminsListDto>(<any>null);
    }

    postText(textDto: TextDto): Observable<StringIdsDto> {
        let url_ = this.baseUrl + "/api/Text/addText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(textDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostText(<any>response_);
                } catch (e) {
                    return <Observable<StringIdsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringIdsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPostText(response: HttpResponseBase): Observable<StringIdsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringIdsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringIdsDto>(<any>null);
    }

    putText(textDto: TextDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Text/updateText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(textDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutText(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPutText(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    deleteText(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Text/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Text/backup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    restoreFromBackup(file: FileParameter | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Text/restoreFromBackup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreFromBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreFromBackup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreFromBackup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getTextPrview(isHidden: boolean, text: string): Observable<TextForGuessingDto> {
        let url_ = this.baseUrl + "/api/Text/preview/{isHidden}";
        if (isHidden === undefined || isHidden === null)
            throw new Error("The parameter 'isHidden' must be defined.");
        url_ = url_.replace("{isHidden}", encodeURIComponent("" + isHidden));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(text);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTextPrview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTextPrview(<any>response_);
                } catch (e) {
                    return <Observable<TextForGuessingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TextForGuessingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTextPrview(response: HttpResponseBase): Observable<TextForGuessingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TextForGuessingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TextForGuessingDto>(<any>null);
    }

    resave(): Observable<void> {
        let url_ = this.baseUrl + "/api/Text/resave";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResave(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class WordClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getWordsInParagraphs(id: string | null): Observable<TextDto> {
        let url_ = this.baseUrl + "/api/Word/wordsInParagraphs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWordsInParagraphs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWordsInParagraphs(<any>response_);
                } catch (e) {
                    return <Observable<TextDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TextDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWordsInParagraphs(response: HttpResponseBase): Observable<TextDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TextDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TextDto>(<any>null);
    }

    getWordsCountInParagraphs(id: string | null, mode: string): Observable<TextForGuessingDto> {
        let url_ = this.baseUrl + "/api/Word/{id}/{mode}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined.");
        url_ = url_.replace("{mode}", encodeURIComponent("" + mode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWordsCountInParagraphs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWordsCountInParagraphs(<any>response_);
                } catch (e) {
                    return <Observable<TextForGuessingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TextForGuessingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWordsCountInParagraphs(response: HttpResponseBase): Observable<TextForGuessingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TextForGuessingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TextForGuessingDto>(<any>null);
    }

    getLetter(id: string | null, paragraphIndex: number, wordIndex: number, symbolIndex: number, mode: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Word/letter/{id}/{paragraphIndex}/{wordIndex}/{symbolIndex}/{mode}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (paragraphIndex === undefined || paragraphIndex === null)
            throw new Error("The parameter 'paragraphIndex' must be defined.");
        url_ = url_.replace("{paragraphIndex}", encodeURIComponent("" + paragraphIndex));
        if (wordIndex === undefined || wordIndex === null)
            throw new Error("The parameter 'wordIndex' must be defined.");
        url_ = url_.replace("{wordIndex}", encodeURIComponent("" + wordIndex));
        if (symbolIndex === undefined || symbolIndex === null)
            throw new Error("The parameter 'symbolIndex' must be defined.");
        url_ = url_.replace("{symbolIndex}", encodeURIComponent("" + symbolIndex));
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined.");
        url_ = url_.replace("{mode}", encodeURIComponent("" + mode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLetter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLetter(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLetter(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getWordCorrectness(id: string | null, paragraphIndex: number, wordIndex: number, value: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Word/wordCorrectness/{id}/{paragraphIndex}/{wordIndex}/{value}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (paragraphIndex === undefined || paragraphIndex === null)
            throw new Error("The parameter 'paragraphIndex' must be defined.");
        url_ = url_.replace("{paragraphIndex}", encodeURIComponent("" + paragraphIndex));
        if (wordIndex === undefined || wordIndex === null)
            throw new Error("The parameter 'wordIndex' must be defined.");
        url_ = url_.replace("{wordIndex}", encodeURIComponent("" + wordIndex));
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined.");
        url_ = url_.replace("{value}", encodeURIComponent("" + value));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWordCorrectness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWordCorrectness(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetWordCorrectness(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    postCheckWords(id: string | null, words: string[]): Observable<CorrectWordLocatorsDto[]> {
        let url_ = this.baseUrl + "/api/Word/wordsForCheck/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(words);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostCheckWords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCheckWords(<any>response_);
                } catch (e) {
                    return <Observable<CorrectWordLocatorsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CorrectWordLocatorsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPostCheckWords(response: HttpResponseBase): Observable<CorrectWordLocatorsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CorrectWordLocatorsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorrectWordLocatorsDto[]>(<any>null);
    }

    finishGuessing(id: string | null, mode: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Word/finishGuessing/{id}/{mode}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined.");
        url_ = url_.replace("{mode}", encodeURIComponent("" + mode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishGuessing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishGuessing(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFinishGuessing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HomeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    setLanguage(culture: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/setlanguage/{culture}";
        if (culture === undefined || culture === null)
            throw new Error("The parameter 'culture' must be defined.");
        url_ = url_.replace("{culture}", encodeURIComponent("" + culture));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetLanguage(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSetLanguage(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    get(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/applicationdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUsersAndRoles(): Observable<UserWithRolesViewModel> {
        let url_ = this.baseUrl + "/api/Admin/ur";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersAndRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersAndRoles(<any>response_);
                } catch (e) {
                    return <Observable<UserWithRolesViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserWithRolesViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersAndRoles(response: HttpResponseBase): Observable<UserWithRolesViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWithRolesViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserWithRolesViewModel>(<any>null);
    }

    getUsersAndRolesMO(): Observable<UserWithRolesMOViewModel> {
        let url_ = this.baseUrl + "/api/Admin/urmo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersAndRolesMO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersAndRolesMO(<any>response_);
                } catch (e) {
                    return <Observable<UserWithRolesMOViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserWithRolesMOViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersAndRolesMO(response: HttpResponseBase): Observable<UserWithRolesMOViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWithRolesMOViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserWithRolesMOViewModel>(<any>null);
    }

    getUser(id: number): Observable<ApplicationUserDto> {
        let url_ = this.baseUrl + "/api/Admin/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<ApplicationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDto>(<any>null);
    }

    addUser(userDto: ApplicationUserDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateUser(userDto: ApplicationUserDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BackupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getFullBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Backup/full-bckp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getSQLBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Backup/sql-bckp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSQLBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSQLBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetSQLBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getSpecBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Backup/spec-bckp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpecBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getBlogBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Backup/blog-bckp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlogBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlogBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlogBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    restoreBlogData(file: FileParameter | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Backup/rstr-blog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBlogData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBlogData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBlogData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    restoreSpecData(file: FileParameter | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Backup/rstr-spec";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSpecData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSpecData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreSpecData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BlogClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(isAsc: boolean): Observable<PostDto[]> {
        let url_ = this.baseUrl + "/api/Blog/{isAsc}";
        if (isAsc === undefined || isAsc === null)
            throw new Error("The parameter 'isAsc' must be defined.");
        url_ = url_.replace("{isAsc}", encodeURIComponent("" + isAsc));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PostDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostDto[]>(<any>null);
    }

    getPost(id: number): Observable<SinglePostDto> {
        let url_ = this.baseUrl + "/api/Blog/post/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPost(<any>response_);
                } catch (e) {
                    return <Observable<SinglePostDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SinglePostDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPost(response: HttpResponseBase): Observable<SinglePostDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SinglePostDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SinglePostDto>(<any>null);
    }

    getDescriptions(isAsc: boolean): Observable<PostDescriptionDto[]> {
        let url_ = this.baseUrl + "/api/Blog/descriptions/{isAsc}";
        if (isAsc === undefined || isAsc === null)
            throw new Error("The parameter 'isAsc' must be defined.");
        url_ = url_.replace("{isAsc}", encodeURIComponent("" + isAsc));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDescriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDescriptions(<any>response_);
                } catch (e) {
                    return <Observable<PostDescriptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostDescriptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDescriptions(response: HttpResponseBase): Observable<PostDescriptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDescriptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostDescriptionDto[]>(<any>null);
    }

    getAdditionalInfo(): Observable<AdditionalDto> {
        let url_ = this.baseUrl + "/api/Blog/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdditionalInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdditionalInfo(<any>response_);
                } catch (e) {
                    return <Observable<AdditionalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdditionalDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdditionalInfo(response: HttpResponseBase): Observable<AdditionalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdditionalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdditionalDto>(<any>null);
    }

    getFiltered(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Blog/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFiltered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiltered(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiltered(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    addTopic(topic: string): Observable<number> {
        let url_ = this.baseUrl + "/api/Blog/addTopic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(topic);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTopic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTopic(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddTopic(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    add(post: PostWriteDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Blog/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(post);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(post: PostWriteDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Blog/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(post);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Blog/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChatClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUsersForChat(filter: string | null): Observable<ChatAvailableUsersListDto> {
        let url_ = this.baseUrl + "/api/Chat/usersForChat/{filter}";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined.");
        url_ = url_.replace("{filter}", encodeURIComponent("" + filter));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersForChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersForChat(<any>response_);
                } catch (e) {
                    return <Observable<ChatAvailableUsersListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatAvailableUsersListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersForChat(response: HttpResponseBase): Observable<ChatAvailableUsersListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatAvailableUsersListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatAvailableUsersListDto>(<any>null);
    }

    getPreviousMessages(toUserId: number, messageCount: number, lastId: number): Observable<UserMessageDto[]> {
        let url_ = this.baseUrl + "/api/Chat/prevMeesages/{toUserId}/{messageCount}/{lastId}";
        if (toUserId === undefined || toUserId === null)
            throw new Error("The parameter 'toUserId' must be defined.");
        url_ = url_.replace("{toUserId}", encodeURIComponent("" + toUserId));
        if (messageCount === undefined || messageCount === null)
            throw new Error("The parameter 'messageCount' must be defined.");
        url_ = url_.replace("{messageCount}", encodeURIComponent("" + messageCount));
        if (lastId === undefined || lastId === null)
            throw new Error("The parameter 'lastId' must be defined.");
        url_ = url_.replace("{lastId}", encodeURIComponent("" + lastId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPreviousMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPreviousMessages(<any>response_);
                } catch (e) {
                    return <Observable<UserMessageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserMessageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPreviousMessages(response: HttpResponseBase): Observable<UserMessageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserMessageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMessageDto[]>(<any>null);
    }

    getSignalRReceiverIdAndSend(message: string | null, receiverId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Chat/send/{message}/{receiverId}";
        if (message === undefined || message === null)
            throw new Error("The parameter 'message' must be defined.");
        url_ = url_.replace("{message}", encodeURIComponent("" + message));
        if (receiverId === undefined || receiverId === null)
            throw new Error("The parameter 'receiverId' must be defined.");
        url_ = url_.replace("{receiverId}", encodeURIComponent("" + receiverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSignalRReceiverIdAndSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSignalRReceiverIdAndSend(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSignalRReceiverIdAndSend(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DebianFAIClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPreseed(settings: PreseedSettingsViewModel): Observable<string> {
        let url_ = this.baseUrl + "/api/DebianFAI/preseed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPreseed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPreseed(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPreseed(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getDefaultSettings(): Observable<PreseedSettingsViewModel> {
        let url_ = this.baseUrl + "/api/DebianFAI/defaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<PreseedSettingsViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PreseedSettingsViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultSettings(response: HttpResponseBase): Observable<PreseedSettingsViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreseedSettingsViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreseedSettingsViewModel>(<any>null);
    }

    getImage(settings: PreseedSettingsViewModel): Observable<string> {
        let url_ = this.baseUrl + "/api/DebianFAI/image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    downloadFile(fileName: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/DebianFAI/downloadFile/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FeedbackClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getFeedbacks(query: FeedbackQueryViewModel): Observable<PagedDataViewModelOfFeedbackDto> {
        let url_ = this.baseUrl + "/api/Feedback/queried";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeedbacks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeedbacks(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataViewModelOfFeedbackDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataViewModelOfFeedbackDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFeedbacks(response: HttpResponseBase): Observable<PagedDataViewModelOfFeedbackDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataViewModelOfFeedbackDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataViewModelOfFeedbackDto>(<any>null);
    }

    postFeedbacks(feedbackDto: FeedbackInsertDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Feedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feedbackDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostFeedbacks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFeedbacks(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processPostFeedbacks(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LogClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getFilesArray(isError: boolean): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Log/files/{isError}";
        if (isError === undefined || isError === null)
            throw new Error("The parameter 'isError' must be defined.");
        url_ = url_.replace("{isError}", encodeURIComponent("" + isError));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilesArray(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilesArray(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilesArray(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    getLogs(filename: string | null): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/Log/logs/{filename}";
        if (filename === undefined || filename === null)
            throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace("{filename}", encodeURIComponent("" + filename));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogs(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogs(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    getErrors(filename: string | null): Observable<ErrorLogDto[]> {
        let url_ = this.baseUrl + "/api/Log/errs/{filename}";
        if (filename === undefined || filename === null)
            throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace("{filename}", encodeURIComponent("" + filename));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetErrors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetErrors(<any>response_);
                } catch (e) {
                    return <Observable<ErrorLogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ErrorLogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetErrors(response: HttpResponseBase): Observable<ErrorLogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ErrorLogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ErrorLogDto[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OCRClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getRecognized(languages: string | null, base64: string): Observable<string> {
        let url_ = this.baseUrl + "/api/OCR/recognize/{languages}";
        if (languages === undefined || languages === null)
            throw new Error("The parameter 'languages' must be defined.");
        url_ = url_.replace("{languages}", encodeURIComponent("" + languages));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(base64);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecognized(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecognized(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecognized(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getRecognizedImage(languages: string | null, imageParams: ImageParamsViewModel): Observable<string> {
        let url_ = this.baseUrl + "/api/OCR/recognizeImg/{languages}";
        if (languages === undefined || languages === null)
            throw new Error("The parameter 'languages' must be defined.");
        url_ = url_.replace("{languages}", encodeURIComponent("" + languages));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(imageParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecognizedImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecognizedImage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecognizedImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SpecClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getHeaderDescription(): Observable<TypeHeaderDto[]> {
        let url_ = this.baseUrl + "/api/Spec/header";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHeaderDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHeaderDescription(<any>response_);
                } catch (e) {
                    return <Observable<TypeHeaderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TypeHeaderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHeaderDescription(response: HttpResponseBase): Observable<TypeHeaderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TypeHeaderDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TypeHeaderDto[]>(<any>null);
    }

    getVideoDescriptionList(id: number): Observable<CourseDto> {
        let url_ = this.baseUrl + "/api/Spec/video/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoDescriptionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoDescriptionList(<any>response_);
                } catch (e) {
                    return <Observable<CourseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVideoDescriptionList(response: HttpResponseBase): Observable<CourseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SqlBackupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getBackup(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/SqlBackup/backup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBackup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    restoreFromBackup(file: FileParameter | null): Observable<void> {
        let url_ = this.baseUrl + "/api/SqlBackup/restoreFromBackup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreFromBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreFromBackup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreFromBackup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StegClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    simplePictureInject(settings: StegSettingsDto): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Steg/inject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimplePictureInject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimplePictureInject(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSimplePictureInject(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    simplePictureEject(settings: StegSettingsDto): Observable<string> {
        let url_ = this.baseUrl + "/api/Steg/eject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimplePictureEject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimplePictureEject(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSimplePictureEject(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TimeStampVideoContrtollerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(videoId: number): Observable<TimeStampUserDto[]> {
        let url_ = this.baseUrl + "/api/TimeStampVideoContrtoller/videoTimeCodes/{videoId}";
        if (videoId === undefined || videoId === null)
            throw new Error("The parameter 'videoId' must be defined.");
        url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TimeStampUserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TimeStampUserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TimeStampUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimeStampUserDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimeStampUserDto[]>(<any>null);
    }

    insert(videoId: number, userId: number, seconds: number, comment: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/TimeStampVideoContrtoller?";
        if (videoId === undefined || videoId === null)
            throw new Error("The parameter 'videoId' must be defined and cannot be null.");
        else
            url_ += "VideoId=" + encodeURIComponent("" + videoId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (seconds === undefined || seconds === null)
            throw new Error("The parameter 'seconds' must be defined and cannot be null.");
        else
            url_ += "Seconds=" + encodeURIComponent("" + seconds) + "&";
        if (comment === undefined)
            throw new Error("The parameter 'comment' must be defined.");
        else if(comment !== null)
            url_ += "Comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    update(videoId: number, userId: number, seconds: number, comment: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/TimeStampVideoContrtoller?";
        if (videoId === undefined || videoId === null)
            throw new Error("The parameter 'videoId' must be defined and cannot be null.");
        else
            url_ += "VideoId=" + encodeURIComponent("" + videoId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (seconds === undefined || seconds === null)
            throw new Error("The parameter 'seconds' must be defined and cannot be null.");
        else
            url_ += "Seconds=" + encodeURIComponent("" + seconds) + "&";
        if (comment === undefined)
            throw new Error("The parameter 'comment' must be defined.");
        else if(comment !== null)
            url_ += "Comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteTimeStamp(videoId: number, userId: number, seconds: number, comment: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/TimeStampVideoContrtoller?";
        if (videoId === undefined || videoId === null)
            throw new Error("The parameter 'videoId' must be defined and cannot be null.");
        else
            url_ += "VideoId=" + encodeURIComponent("" + videoId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (seconds === undefined || seconds === null)
            throw new Error("The parameter 'seconds' must be defined and cannot be null.");
        else
            url_ += "Seconds=" + encodeURIComponent("" + seconds) + "&";
        if (comment === undefined)
            throw new Error("The parameter 'comment' must be defined.");
        else if(comment !== null)
            url_ += "Comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTimeStamp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTimeStamp(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTimeStamp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    insert2(videoId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/TimeStampVideoContrtoller/{videoId}";
        if (videoId === undefined || videoId === null)
            throw new Error("The parameter 'videoId' must be defined.");
        url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAdmins(): Observable<UserViewModel[]> {
        let url_ = this.baseUrl + "/api/User/admins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdmins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdmins(<any>response_);
                } catch (e) {
                    return <Observable<UserViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdmins(response: HttpResponseBase): Observable<UserViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewModel[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class YouTubeDownloaderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getVideoInfo(link: string | null): Observable<VideoStreamInfoViewModel> {
        let url_ = this.baseUrl + "/api/YouTubeDownloader/videoInfo/{link}";
        if (link === undefined || link === null)
            throw new Error("The parameter 'link' must be defined.");
        url_ = url_.replace("{link}", encodeURIComponent("" + link));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoInfo(<any>response_);
                } catch (e) {
                    return <Observable<VideoStreamInfoViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<VideoStreamInfoViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetVideoInfo(response: HttpResponseBase): Observable<VideoStreamInfoViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoStreamInfoViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VideoStreamInfoViewModel>(<any>null);
    }

    download(link: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/YouTubeDownloader/download/{link}";
        if (link === undefined || link === null)
            throw new Error("The parameter 'link' must be defined.");
        url_ = url_.replace("{link}", encodeURIComponent("" + link));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    whoAmI(): Observable<string> {
        let url_ = this.baseUrl + "/api/Account/whoAmI";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWhoAmI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWhoAmI(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processWhoAmI(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    login(model: LoginViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    register(model: RegisterViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/rgstr";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    confirmEmail(userId: string | null, code: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined)
            throw new Error("The parameter 'code' must be defined.");
        else if(code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    forgotPassword(model: ForgotPasswordViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    resetPassword(model: ResetPasswordViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/resetpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    sendCode(returnUrl: string | null | undefined, rememberMe: boolean | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/SendCode?";
        if (returnUrl !== undefined && returnUrl !== null)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        if (rememberMe === null)
            throw new Error("The parameter 'rememberMe' cannot be null.");
        else if (rememberMe !== undefined)
            url_ += "rememberMe=" + encodeURIComponent("" + rememberMe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendCode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSendCode(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    sendCode2(model: SendCodeViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/SendCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendCode2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendCode2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSendCode2(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    verifyCode(provider: string | null, rememberMe: boolean, returnUrl: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/VerifyCode?";
        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else if(provider !== null)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&";
        if (rememberMe === undefined || rememberMe === null)
            throw new Error("The parameter 'rememberMe' must be defined and cannot be null.");
        else
            url_ += "rememberMe=" + encodeURIComponent("" + rememberMe) + "&";
        if (returnUrl !== undefined && returnUrl !== null)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyCode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyCode(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    verifyCode2(provider: string | null, code: string | null, returnUrl: string | null, rememberBrowser: boolean, rememberMe: boolean): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/VerifyCode?";
        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else if(provider !== null)
            url_ += "Provider=" + encodeURIComponent("" + provider) + "&";
        if (code === undefined)
            throw new Error("The parameter 'code' must be defined.");
        else if(code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else if(returnUrl !== null)
            url_ += "ReturnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        if (rememberBrowser === undefined || rememberBrowser === null)
            throw new Error("The parameter 'rememberBrowser' must be defined and cannot be null.");
        else
            url_ += "RememberBrowser=" + encodeURIComponent("" + rememberBrowser) + "&";
        if (rememberMe === undefined || rememberMe === null)
            throw new Error("The parameter 'rememberMe' must be defined and cannot be null.");
        else
            url_ += "RememberMe=" + encodeURIComponent("" + rememberMe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyCode2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyCode2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyCode2(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    logOff(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOff(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processLogOff(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getCaptchaImage(): Observable<CaptchaDto> {
        let url_ = this.baseUrl + "/api/Account/captchaImg";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaptchaImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaptchaImage(<any>response_);
                } catch (e) {
                    return <Observable<CaptchaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CaptchaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCaptchaImage(response: HttpResponseBase): Observable<CaptchaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaptchaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaptchaDto>(<any>null);
    }

    hiddenRegister(model: RegisterViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/hiddenRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHiddenRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHiddenRegister(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processHiddenRegister(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AuthorizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    exchange(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/connect/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchange(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processExchange(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    authorize(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/connect/authorize";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processAuthorize(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AutogenerationSupportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getChatSupport(): Observable<MessageTransferredDto> {
        let url_ = this.baseUrl + "/api/AutogenerationSupport/support1";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatSupport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatSupport(<any>response_);
                } catch (e) {
                    return <Observable<MessageTransferredDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageTransferredDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChatSupport(response: HttpResponseBase): Observable<MessageTransferredDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageTransferredDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageTransferredDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Content";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getCultures(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Content/cultures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCultures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCultures(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetCultures(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IssuesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getKnownError(): Observable<void> {
        let url_ = this.baseUrl + "/api/Issues/getKnownError";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKnownError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKnownError(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetKnownError(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getUnknownError(): Observable<void> {
        let url_ = this.baseUrl + "/api/Issues/getUnknownError";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnknownError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnknownError(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnknownError(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getUnauthorizedAccessError(): Observable<void> {
        let url_ = this.baseUrl + "/api/Issues/getUnauthorizedAccessError";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnauthorizedAccessError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnauthorizedAccessError(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnauthorizedAccessError(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ManageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    userInfo(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUserInfo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    userInfo2(model: IndexViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserInfo2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserInfo2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUserInfo2(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    changePassword(model: ChangePasswordViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/changepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    setPassword(model: SetPasswordViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/setpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    userPhoto(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/photo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPhoto(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUserPhoto(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    userPhoto2(file: FileParameter | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/photo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPhoto2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPhoto2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUserPhoto2(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getLogins(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/getlogins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogins(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogins(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getUsersByEmails(emails: string[]): Observable<ApplicationUser[]> {
        let url_ = this.baseUrl + "/api/Manage/getUsersByEmails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(emails);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByEmails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByEmails(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUser[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUser[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersByEmails(response: HttpResponseBase): Observable<ApplicationUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationUser.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser[]>(<any>null);
    }

    delete(email: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Manage/delete?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeLogin(account: RemoveLoginViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/removelogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLogin(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveLogin(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    manageLogins(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/managelogins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManageLogins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManageLogins(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processManageLogins(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    linkLogin(provider: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/linklogin?";
        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else if(provider !== null)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkLogin(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processLinkLogin(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    linkLoginCallback(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/linklogincallback";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkLoginCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkLoginCallback(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processLinkLoginCallback(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    twoFactorAuthentication(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/twofactorauthentication";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTwoFactorAuthentication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTwoFactorAuthentication(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processTwoFactorAuthentication(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    disable2fa(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/disable2fa";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable2fa(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDisable2fa(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    enableAuthenticator(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/enableauthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableAuthenticator(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processEnableAuthenticator(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    enableAuthenticator2(model: EnableAuthenticatorViewModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/enableauthenticator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableAuthenticator2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableAuthenticator2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processEnableAuthenticator2(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    resetAuthenticator(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/resetauthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetAuthenticator(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processResetAuthenticator(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    generateRecoveryCodes(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Manage/generaterecoverycodes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateRecoveryCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateRecoveryCodes(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateRecoveryCodes(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

export class PagedDataViewModelOfCrosswordDescriptionDto implements IPagedDataViewModelOfCrosswordDescriptionDto {
    count!: number;
    data?: CrosswordDescriptionDto[] | undefined;

    constructor(data?: IPagedDataViewModelOfCrosswordDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CrosswordDescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedDataViewModelOfCrosswordDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataViewModelOfCrosswordDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedDataViewModelOfCrosswordDescriptionDto {
    count: number;
    data?: CrosswordDescriptionDto[] | undefined;
}

export class CrosswordDescriptionDto implements ICrosswordDescriptionDto {
    id!: number;
    name?: string | undefined;
    width!: number;
    height!: number;
    assigneeId!: number;
    country?: string | undefined;

    constructor(data?: ICrosswordDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.assigneeId = _data["assigneeId"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): CrosswordDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrosswordDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["width"] = this.width;
        data["height"] = this.height;
        data["assigneeId"] = this.assigneeId;
        data["country"] = this.country;
        return data; 
    }
}

export interface ICrosswordDescriptionDto {
    id: number;
    name?: string | undefined;
    width: number;
    height: number;
    assigneeId: number;
    country?: string | undefined;
}

export class QueryViewModel implements IQueryViewModel {
    page!: number;
    elementsPerPage!: number;
    isAscending!: boolean;
    sortingName?: string | undefined;
    filteringProperties?: { [key: string]: string; } | undefined;

    constructor(data?: IQueryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.elementsPerPage = _data["elementsPerPage"];
            this.isAscending = _data["isAscending"];
            this.sortingName = _data["sortingName"];
            if (_data["filteringProperties"]) {
                this.filteringProperties = {} as any;
                for (let key in _data["filteringProperties"]) {
                    if (_data["filteringProperties"].hasOwnProperty(key))
                        this.filteringProperties![key] = _data["filteringProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): QueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new QueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["elementsPerPage"] = this.elementsPerPage;
        data["isAscending"] = this.isAscending;
        data["sortingName"] = this.sortingName;
        if (this.filteringProperties) {
            data["filteringProperties"] = {};
            for (let key in this.filteringProperties) {
                if (this.filteringProperties.hasOwnProperty(key))
                    data["filteringProperties"][key] = this.filteringProperties[key];
            }
        }
        return data; 
    }
}

export interface IQueryViewModel {
    page: number;
    elementsPerPage: number;
    isAscending: boolean;
    sortingName?: string | undefined;
    filteringProperties?: { [key: string]: string; } | undefined;
}

export class CrosswordQueryViewModel extends QueryViewModel implements ICrosswordQueryViewModel {

    constructor(data?: ICrosswordQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CrosswordQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CrosswordQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICrosswordQueryViewModel extends IQueryViewModel {
}

export class PagedDataViewModelOfCrosswordDescriptionEnhancedDto implements IPagedDataViewModelOfCrosswordDescriptionEnhancedDto {
    count!: number;
    data?: CrosswordDescriptionEnhancedDto[] | undefined;

    constructor(data?: IPagedDataViewModelOfCrosswordDescriptionEnhancedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CrosswordDescriptionEnhancedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedDataViewModelOfCrosswordDescriptionEnhancedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataViewModelOfCrosswordDescriptionEnhancedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedDataViewModelOfCrosswordDescriptionEnhancedDto {
    count: number;
    data?: CrosswordDescriptionEnhancedDto[] | undefined;
}

export class CrosswordDescriptionEnhancedDto extends CrosswordDescriptionDto implements ICrosswordDescriptionEnhancedDto {
    assignee?: string | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;

    constructor(data?: ICrosswordDescriptionEnhancedDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.assignee = _data["assignee"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CrosswordDescriptionEnhancedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrosswordDescriptionEnhancedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ICrosswordDescriptionEnhancedDto extends ICrosswordDescriptionDto {
    assignee?: string | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
}

export class AdminCrosswordQueryViewModel extends CrosswordQueryViewModel implements IAdminCrosswordQueryViewModel {
    includeAssignee!: boolean;
    includeCreateDate!: boolean;
    includeUpdateDate!: boolean;

    constructor(data?: IAdminCrosswordQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.includeAssignee = _data["includeAssignee"];
            this.includeCreateDate = _data["includeCreateDate"];
            this.includeUpdateDate = _data["includeUpdateDate"];
        }
    }

    static fromJS(data: any): AdminCrosswordQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCrosswordQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeAssignee"] = this.includeAssignee;
        data["includeCreateDate"] = this.includeCreateDate;
        data["includeUpdateDate"] = this.includeUpdateDate;
        super.toJSON(data);
        return data; 
    }
}

export interface IAdminCrosswordQueryViewModel extends ICrosswordQueryViewModel {
    includeAssignee: boolean;
    includeCreateDate: boolean;
    includeUpdateDate: boolean;
}

export class CrosswordWithAdminsListDto implements ICrosswordWithAdminsListDto {
    crossword?: CrosswordDto | undefined;
    admins?: UserViewModel[] | undefined;

    constructor(data?: ICrosswordWithAdminsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.crossword = _data["crossword"] ? CrosswordDto.fromJS(_data["crossword"]) : <any>undefined;
            if (Array.isArray(_data["admins"])) {
                this.admins = [] as any;
                for (let item of _data["admins"])
                    this.admins!.push(UserViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CrosswordWithAdminsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrosswordWithAdminsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["crossword"] = this.crossword ? this.crossword.toJSON() : <any>undefined;
        if (Array.isArray(this.admins)) {
            data["admins"] = [];
            for (let item of this.admins)
                data["admins"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICrosswordWithAdminsListDto {
    crossword?: CrosswordDto | undefined;
    admins?: UserViewModel[] | undefined;
}

export class CrosswordDto implements ICrosswordDto {
    id!: number;
    crosswordDescriptionId!: number;
    title?: string | undefined;
    subTitle?: string | undefined;
    width!: number;
    height!: number;
    assigneeId!: number;
    country?: string | undefined;
    complexity!: number;
    wordDescriptionIds?: number[] | undefined;

    constructor(data?: ICrosswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.crosswordDescriptionId = _data["crosswordDescriptionId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.assigneeId = _data["assigneeId"];
            this.country = _data["country"];
            this.complexity = _data["complexity"];
            if (Array.isArray(_data["wordDescriptionIds"])) {
                this.wordDescriptionIds = [] as any;
                for (let item of _data["wordDescriptionIds"])
                    this.wordDescriptionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CrosswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrosswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["crosswordDescriptionId"] = this.crosswordDescriptionId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["width"] = this.width;
        data["height"] = this.height;
        data["assigneeId"] = this.assigneeId;
        data["country"] = this.country;
        data["complexity"] = this.complexity;
        if (Array.isArray(this.wordDescriptionIds)) {
            data["wordDescriptionIds"] = [];
            for (let item of this.wordDescriptionIds)
                data["wordDescriptionIds"].push(item);
        }
        return data; 
    }
}

export interface ICrosswordDto {
    id: number;
    crosswordDescriptionId: number;
    title?: string | undefined;
    subTitle?: string | undefined;
    width: number;
    height: number;
    assigneeId: number;
    country?: string | undefined;
    complexity: number;
    wordDescriptionIds?: number[] | undefined;
}

export class UserViewModel implements IUserViewModel {
    id!: number;
    email?: string | undefined;

    constructor(data?: IUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        return data; 
    }
}

export interface IUserViewModel {
    id: number;
    email?: string | undefined;
}

export class LongIdsDto implements ILongIdsDto {
    ids?: number[] | undefined;

    constructor(data?: ILongIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): LongIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LongIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface ILongIdsDto {
    ids?: number[] | undefined;
}

export class FileNameViewModel implements IFileNameViewModel {
    name?: string | undefined;

    constructor(data?: IFileNameViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FileNameViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new FileNameViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IFileNameViewModel {
    name?: string | undefined;
}

export class VideoFileViewModel implements IVideoFileViewModel {
    fileName?: string | undefined;
    ttl!: number;

    constructor(data?: IVideoFileViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.ttl = _data["ttl"];
        }
    }

    static fromJS(data: any): VideoFileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VideoFileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["ttl"] = this.ttl;
        return data; 
    }
}

export interface IVideoFileViewModel {
    fileName?: string | undefined;
    ttl: number;
}

export class CuttingOptionsViewModel implements ICuttingOptionsViewModel {
    fileName?: string | undefined;
    from!: number;
    to!: number;

    constructor(data?: ICuttingOptionsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): CuttingOptionsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CuttingOptionsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

export interface ICuttingOptionsViewModel {
    fileName?: string | undefined;
    from: number;
    to: number;
}

export class PagedDataViewModelOfQuestionAndWordDescriptionDto implements IPagedDataViewModelOfQuestionAndWordDescriptionDto {
    count!: number;
    data?: QuestionAndWordDescriptionDto[] | undefined;

    constructor(data?: IPagedDataViewModelOfQuestionAndWordDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(QuestionAndWordDescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedDataViewModelOfQuestionAndWordDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataViewModelOfQuestionAndWordDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedDataViewModelOfQuestionAndWordDescriptionDto {
    count: number;
    data?: QuestionAndWordDescriptionDto[] | undefined;
}

export class QuestionAndWordDescriptionDto implements IQuestionAndWordDescriptionDto {
    wordDescriptionId!: number;
    questionDescriptionId!: number;
    startPointX!: number;
    startPointY!: number;
    direction!: number;
    question?: string | undefined;
    answer?: string | undefined;

    constructor(data?: IQuestionAndWordDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wordDescriptionId = _data["wordDescriptionId"];
            this.questionDescriptionId = _data["questionDescriptionId"];
            this.startPointX = _data["startPointX"];
            this.startPointY = _data["startPointY"];
            this.direction = _data["direction"];
            this.question = _data["question"];
            this.answer = _data["answer"];
        }
    }

    static fromJS(data: any): QuestionAndWordDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionAndWordDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wordDescriptionId"] = this.wordDescriptionId;
        data["questionDescriptionId"] = this.questionDescriptionId;
        data["startPointX"] = this.startPointX;
        data["startPointY"] = this.startPointY;
        data["direction"] = this.direction;
        data["question"] = this.question;
        data["answer"] = this.answer;
        return data; 
    }
}

export interface IQuestionAndWordDescriptionDto {
    wordDescriptionId: number;
    questionDescriptionId: number;
    startPointX: number;
    startPointY: number;
    direction: number;
    question?: string | undefined;
    answer?: string | undefined;
}

export class QuestionQueryViewModel extends QueryViewModel implements IQuestionQueryViewModel {

    constructor(data?: IQuestionQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): QuestionQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IQuestionQueryViewModel extends IQueryViewModel {
}

export class ResultEnhancedDto implements IResultEnhancedDto {
    results?: ResultDto[] | undefined;
    users?: UserViewModel[] | undefined;

    constructor(data?: IResultEnhancedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ResultDto.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultEnhancedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultEnhancedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IResultEnhancedDto {
    results?: ResultDto[] | undefined;
    users?: UserViewModel[] | undefined;
}

export class ResultDto implements IResultDto {
    id!: number;
    title?: string | undefined;
    country?: string | undefined;
    calculatedResult?: WordsCalculatedResultDto | undefined;
    mode!: string;
    started!: Date;
    finished!: Date;
    timeSpentMiliSeconds?: number | undefined;
    isCompleted!: boolean;
    errorsCount!: number;

    constructor(data?: IResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.country = _data["country"];
            this.calculatedResult = _data["calculatedResult"] ? WordsCalculatedResultDto.fromJS(_data["calculatedResult"]) : <any>undefined;
            this.mode = _data["mode"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.timeSpentMiliSeconds = _data["timeSpentMiliSeconds"];
            this.isCompleted = _data["isCompleted"];
            this.errorsCount = _data["errorsCount"];
        }
    }

    static fromJS(data: any): ResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["country"] = this.country;
        data["calculatedResult"] = this.calculatedResult ? this.calculatedResult.toJSON() : <any>undefined;
        data["mode"] = this.mode;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["timeSpentMiliSeconds"] = this.timeSpentMiliSeconds;
        data["isCompleted"] = this.isCompleted;
        data["errorsCount"] = this.errorsCount;
        return data; 
    }
}

export interface IResultDto {
    id: number;
    title?: string | undefined;
    country?: string | undefined;
    calculatedResult?: WordsCalculatedResultDto | undefined;
    mode: string;
    started: Date;
    finished: Date;
    timeSpentMiliSeconds?: number | undefined;
    isCompleted: boolean;
    errorsCount: number;
}

export class WordsCalculatedResultDto implements IWordsCalculatedResultDto {
    symbolsCountWithoutSign!: number;
    guessedSymbolsCount!: number;
    hintedSymbolsCount!: number;
    wordsCountWithoutSign!: number;
    fullyGuessedWordsCount!: number;
    partitionallyGuessedWordsCount!: number;
    totallyHintedWordsCount!: number;

    constructor(data?: IWordsCalculatedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolsCountWithoutSign = _data["symbolsCountWithoutSign"];
            this.guessedSymbolsCount = _data["guessedSymbolsCount"];
            this.hintedSymbolsCount = _data["hintedSymbolsCount"];
            this.wordsCountWithoutSign = _data["wordsCountWithoutSign"];
            this.fullyGuessedWordsCount = _data["fullyGuessedWordsCount"];
            this.partitionallyGuessedWordsCount = _data["partitionallyGuessedWordsCount"];
            this.totallyHintedWordsCount = _data["totallyHintedWordsCount"];
        }
    }

    static fromJS(data: any): WordsCalculatedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WordsCalculatedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbolsCountWithoutSign"] = this.symbolsCountWithoutSign;
        data["guessedSymbolsCount"] = this.guessedSymbolsCount;
        data["hintedSymbolsCount"] = this.hintedSymbolsCount;
        data["wordsCountWithoutSign"] = this.wordsCountWithoutSign;
        data["fullyGuessedWordsCount"] = this.fullyGuessedWordsCount;
        data["partitionallyGuessedWordsCount"] = this.partitionallyGuessedWordsCount;
        data["totallyHintedWordsCount"] = this.totallyHintedWordsCount;
        return data; 
    }
}

export interface IWordsCalculatedResultDto {
    symbolsCountWithoutSign: number;
    guessedSymbolsCount: number;
    hintedSymbolsCount: number;
    wordsCountWithoutSign: number;
    fullyGuessedWordsCount: number;
    partitionallyGuessedWordsCount: number;
    totallyHintedWordsCount: number;
}

export class TextForGuessingDto implements ITextForGuessingDto {
    wordsCounts?: string[][] | undefined;
    mergedText?: string[][][] | undefined;
    resultsEncodedString?: boolean[] | undefined;
    errorsForJoined?: string[] | undefined;
    errorsForSeparated?: ErrorForSeparatedDto[] | undefined;
    isStarted!: boolean;

    constructor(data?: ITextForGuessingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["wordsCounts"])) {
                this.wordsCounts = [] as any;
                for (let item of _data["wordsCounts"])
                    this.wordsCounts!.push(item);
            }
            if (Array.isArray(_data["mergedText"])) {
                this.mergedText = [] as any;
                for (let item of _data["mergedText"])
                    this.mergedText!.push(item);
            }
            if (Array.isArray(_data["resultsEncodedString"])) {
                this.resultsEncodedString = [] as any;
                for (let item of _data["resultsEncodedString"])
                    this.resultsEncodedString!.push(item);
            }
            if (Array.isArray(_data["errorsForJoined"])) {
                this.errorsForJoined = [] as any;
                for (let item of _data["errorsForJoined"])
                    this.errorsForJoined!.push(item);
            }
            if (Array.isArray(_data["errorsForSeparated"])) {
                this.errorsForSeparated = [] as any;
                for (let item of _data["errorsForSeparated"])
                    this.errorsForSeparated!.push(ErrorForSeparatedDto.fromJS(item));
            }
            this.isStarted = _data["isStarted"];
        }
    }

    static fromJS(data: any): TextForGuessingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextForGuessingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.wordsCounts)) {
            data["wordsCounts"] = [];
            for (let item of this.wordsCounts)
                data["wordsCounts"].push(item);
        }
        if (Array.isArray(this.mergedText)) {
            data["mergedText"] = [];
            for (let item of this.mergedText)
                data["mergedText"].push(item);
        }
        if (Array.isArray(this.resultsEncodedString)) {
            data["resultsEncodedString"] = [];
            for (let item of this.resultsEncodedString)
                data["resultsEncodedString"].push(item);
        }
        if (Array.isArray(this.errorsForJoined)) {
            data["errorsForJoined"] = [];
            for (let item of this.errorsForJoined)
                data["errorsForJoined"].push(item);
        }
        if (Array.isArray(this.errorsForSeparated)) {
            data["errorsForSeparated"] = [];
            for (let item of this.errorsForSeparated)
                data["errorsForSeparated"].push(item.toJSON());
        }
        data["isStarted"] = this.isStarted;
        return data; 
    }
}

export interface ITextForGuessingDto {
    wordsCounts?: string[][] | undefined;
    mergedText?: string[][][] | undefined;
    resultsEncodedString?: boolean[] | undefined;
    errorsForJoined?: string[] | undefined;
    errorsForSeparated?: ErrorForSeparatedDto[] | undefined;
    isStarted: boolean;
}

export class ErrorForSeparatedDto implements IErrorForSeparatedDto {
    wordAddress?: WordAddress | undefined;
    errors?: string[] | undefined;

    constructor(data?: IErrorForSeparatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wordAddress = _data["wordAddress"] ? WordAddress.fromJS(_data["wordAddress"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ErrorForSeparatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorForSeparatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wordAddress"] = this.wordAddress ? this.wordAddress.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IErrorForSeparatedDto {
    wordAddress?: WordAddress | undefined;
    errors?: string[] | undefined;
}

export class WordAddress implements IWordAddress {
    paragraphIndex!: number;
    wordIndex!: number;

    constructor(data?: IWordAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paragraphIndex = _data["paragraphIndex"];
            this.wordIndex = _data["wordIndex"];
        }
    }

    static fromJS(data: any): WordAddress {
        data = typeof data === 'object' ? data : {};
        let result = new WordAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paragraphIndex"] = this.paragraphIndex;
        data["wordIndex"] = this.wordIndex;
        return data; 
    }
}

export interface IWordAddress {
    paragraphIndex: number;
    wordIndex: number;
}

export class ResultIdDto implements IResultIdDto {
    textId?: string | undefined;
    mode!: string;

    constructor(data?: IResultIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.textId = _data["textId"];
            this.mode = _data["mode"];
        }
    }

    static fromJS(data: any): ResultIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["textId"] = this.textId;
        data["mode"] = this.mode;
        return data; 
    }
}

export interface IResultIdDto {
    textId?: string | undefined;
    mode: string;
}

export class ResultUpdateTimeDto extends ResultIdDto implements IResultUpdateTimeDto {
    timeSpent!: number;

    constructor(data?: IResultUpdateTimeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.timeSpent = _data["timeSpent"];
        }
    }

    static fromJS(data: any): ResultUpdateTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultUpdateTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSpent"] = this.timeSpent;
        super.toJSON(data);
        return data; 
    }
}

export interface IResultUpdateTimeDto extends IResultIdDto {
    timeSpent: number;
}

export class PagedDataViewModelOfTextDescriptionDto implements IPagedDataViewModelOfTextDescriptionDto {
    count!: number;
    data?: TextDescriptionDto[] | undefined;

    constructor(data?: IPagedDataViewModelOfTextDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TextDescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedDataViewModelOfTextDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataViewModelOfTextDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedDataViewModelOfTextDescriptionDto {
    count: number;
    data?: TextDescriptionDto[] | undefined;
}

export class TextDescriptionDto implements ITextDescriptionDto {
    textId?: string | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;
    audioName?: string | undefined;
    videoName?: string | undefined;
    country?: string | undefined;
    complexity?: number | undefined;

    constructor(data?: ITextDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.textId = _data["textId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.audioName = _data["audioName"];
            this.videoName = _data["videoName"];
            this.country = _data["country"];
            this.complexity = _data["complexity"];
        }
    }

    static fromJS(data: any): TextDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["textId"] = this.textId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["audioName"] = this.audioName;
        data["videoName"] = this.videoName;
        data["country"] = this.country;
        data["complexity"] = this.complexity;
        return data; 
    }
}

export interface ITextDescriptionDto {
    textId?: string | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;
    audioName?: string | undefined;
    videoName?: string | undefined;
    country?: string | undefined;
    complexity?: number | undefined;
}

export class TextQueryViewModel extends QueryViewModel implements ITextQueryViewModel {

    constructor(data?: ITextQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TextQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TextQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITextQueryViewModel extends IQueryViewModel {
}

export class PagedDataViewModelOfTextDescriptionEnhancedDto implements IPagedDataViewModelOfTextDescriptionEnhancedDto {
    count!: number;
    data?: TextDescriptionEnhancedDto[] | undefined;

    constructor(data?: IPagedDataViewModelOfTextDescriptionEnhancedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TextDescriptionEnhancedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedDataViewModelOfTextDescriptionEnhancedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataViewModelOfTextDescriptionEnhancedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedDataViewModelOfTextDescriptionEnhancedDto {
    count: number;
    data?: TextDescriptionEnhancedDto[] | undefined;
}

export class TextDescriptionEnhancedDto extends TextDescriptionDto implements ITextDescriptionEnhancedDto {
    assignee?: string | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;

    constructor(data?: ITextDescriptionEnhancedDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.assignee = _data["assignee"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TextDescriptionEnhancedDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextDescriptionEnhancedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ITextDescriptionEnhancedDto extends ITextDescriptionDto {
    assignee?: string | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
}

export class AdminTextQueryViewModel extends TextQueryViewModel implements IAdminTextQueryViewModel {
    includeAssignee!: boolean;
    includeCreateDate!: boolean;
    includeUpdateDate!: boolean;

    constructor(data?: IAdminTextQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.includeAssignee = _data["includeAssignee"];
            this.includeCreateDate = _data["includeCreateDate"];
            this.includeUpdateDate = _data["includeUpdateDate"];
        }
    }

    static fromJS(data: any): AdminTextQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AdminTextQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeAssignee"] = this.includeAssignee;
        data["includeCreateDate"] = this.includeCreateDate;
        data["includeUpdateDate"] = this.includeUpdateDate;
        super.toJSON(data);
        return data; 
    }
}

export interface IAdminTextQueryViewModel extends ITextQueryViewModel {
    includeAssignee: boolean;
    includeCreateDate: boolean;
    includeUpdateDate: boolean;
}

export class TextWithAdminsListDto implements ITextWithAdminsListDto {
    textDto?: TextDto | undefined;
    admins?: UserViewModel[] | undefined;

    constructor(data?: ITextWithAdminsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.textDto = _data["textDto"] ? TextDto.fromJS(_data["textDto"]) : <any>undefined;
            if (Array.isArray(_data["admins"])) {
                this.admins = [] as any;
                for (let item of _data["admins"])
                    this.admins!.push(UserViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TextWithAdminsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextWithAdminsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["textDto"] = this.textDto ? this.textDto.toJSON() : <any>undefined;
        if (Array.isArray(this.admins)) {
            data["admins"] = [];
            for (let item of this.admins)
                data["admins"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITextWithAdminsListDto {
    textDto?: TextDto | undefined;
    admins?: UserViewModel[] | undefined;
}

export class LogInfo implements ILogInfo {
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
    createdBy?: number | undefined;
    updatedBy?: number | undefined;

    constructor(data?: ILogInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): LogInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LogInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        return data; 
    }
}

export interface ILogInfo {
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
    createdBy?: number | undefined;
    updatedBy?: number | undefined;
}

export class TextDto extends LogInfo implements ITextDto {
    id?: string | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;
    text?: string | undefined;
    audioName?: string | undefined;
    videoName?: string | undefined;
    country?: string | undefined;
    assignee!: number;
    complexity!: number;

    constructor(data?: ITextDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.text = _data["text"];
            this.audioName = _data["audioName"];
            this.videoName = _data["videoName"];
            this.country = _data["country"];
            this.assignee = _data["assignee"];
            this.complexity = _data["complexity"];
        }
    }

    static fromJS(data: any): TextDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["text"] = this.text;
        data["audioName"] = this.audioName;
        data["videoName"] = this.videoName;
        data["country"] = this.country;
        data["assignee"] = this.assignee;
        data["complexity"] = this.complexity;
        super.toJSON(data);
        return data; 
    }
}

export interface ITextDto extends ILogInfo {
    id?: string | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;
    text?: string | undefined;
    audioName?: string | undefined;
    videoName?: string | undefined;
    country?: string | undefined;
    assignee: number;
    complexity: number;
}

export class StringIdsDto implements IStringIdsDto {
    ids?: string[] | undefined;

    constructor(data?: IStringIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): StringIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface IStringIdsDto {
    ids?: string[] | undefined;
}

export class CorrectWordLocatorsDto implements ICorrectWordLocatorsDto {
    word?: string | undefined;
    locators?: WordLocatorDto[] | undefined;

    constructor(data?: ICorrectWordLocatorsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.word = _data["word"];
            if (Array.isArray(_data["locators"])) {
                this.locators = [] as any;
                for (let item of _data["locators"])
                    this.locators!.push(WordLocatorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CorrectWordLocatorsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorrectWordLocatorsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["word"] = this.word;
        if (Array.isArray(this.locators)) {
            data["locators"] = [];
            for (let item of this.locators)
                data["locators"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICorrectWordLocatorsDto {
    word?: string | undefined;
    locators?: WordLocatorDto[] | undefined;
}

export class WordLocatorDto extends WordAddress implements IWordLocatorDto {
    isCapital!: boolean;

    constructor(data?: IWordLocatorDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isCapital = _data["isCapital"];
        }
    }

    static fromJS(data: any): WordLocatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new WordLocatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCapital"] = this.isCapital;
        super.toJSON(data);
        return data; 
    }
}

export interface IWordLocatorDto extends IWordAddress {
    isCapital: boolean;
}

export class UserWithRolesViewModel implements IUserWithRolesViewModel {
    users?: UserWithRoleViewModel[] | undefined;
    roles?: RoleViewModel[] | undefined;

    constructor(data?: IUserWithRolesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserWithRoleViewModel.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserWithRolesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithRolesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserWithRolesViewModel {
    users?: UserWithRoleViewModel[] | undefined;
    roles?: RoleViewModel[] | undefined;
}

export class UserWithRoleViewModel extends UserViewModel implements IUserWithRoleViewModel {
    roleName?: string | undefined;

    constructor(data?: IUserWithRoleViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserWithRoleViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithRoleViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserWithRoleViewModel extends IUserViewModel {
    roleName?: string | undefined;
}

export class RoleViewModel implements IRoleViewModel {
    id!: number;
    name?: string | undefined;

    constructor(data?: IRoleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRoleViewModel {
    id: number;
    name?: string | undefined;
}

export class UserWithRolesMOViewModel implements IUserWithRolesMOViewModel {
    users?: UserWithRoleMOViewModel[] | undefined;
    roles?: RoleViewModel[] | undefined;

    constructor(data?: IUserWithRolesMOViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserWithRoleMOViewModel.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserWithRolesMOViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithRolesMOViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserWithRolesMOViewModel {
    users?: UserWithRoleMOViewModel[] | undefined;
    roles?: RoleViewModel[] | undefined;
}

export class UserWithRoleMOViewModel extends UserViewModel implements IUserWithRoleMOViewModel {
    roleId!: number;

    constructor(data?: IUserWithRoleMOViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserWithRoleMOViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithRoleMOViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserWithRoleMOViewModel extends IUserViewModel {
    roleId: number;
}

export class ApplicationUserDto implements IApplicationUserDto {
    isEnabled!: boolean;
    id!: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed!: boolean;
    passwd?: string | undefined;
    role?: string | undefined;

    constructor(data?: IApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwd = _data["passwd"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): ApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwd"] = this.passwd;
        data["role"] = this.role;
        return data; 
    }
}

export interface IApplicationUserDto {
    isEnabled: boolean;
    id: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed: boolean;
    passwd?: string | undefined;
    role?: string | undefined;
}

export class PostDto extends LogInfo implements IPostDto {
    id!: number;
    header?: string | undefined;
    description?: string | undefined;
    userName?: string | undefined;
    priorityId!: number;
    topicIds?: number[] | undefined;
    message?: string | undefined;

    constructor(data?: IPostDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.description = _data["description"];
            this.userName = _data["userName"];
            this.priorityId = _data["priorityId"];
            if (Array.isArray(_data["topicIds"])) {
                this.topicIds = [] as any;
                for (let item of _data["topicIds"])
                    this.topicIds!.push(item);
            }
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["description"] = this.description;
        data["userName"] = this.userName;
        data["priorityId"] = this.priorityId;
        if (Array.isArray(this.topicIds)) {
            data["topicIds"] = [];
            for (let item of this.topicIds)
                data["topicIds"].push(item);
        }
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IPostDto extends ILogInfo {
    id: number;
    header?: string | undefined;
    description?: string | undefined;
    userName?: string | undefined;
    priorityId: number;
    topicIds?: number[] | undefined;
    message?: string | undefined;
}

export class SinglePostDto extends LogInfo implements ISinglePostDto {
    id!: number;
    header?: string | undefined;
    description?: string | undefined;
    userName?: string | undefined;
    priorityId!: number;
    topics?: string[] | undefined;
    message?: string | undefined;

    constructor(data?: ISinglePostDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.description = _data["description"];
            this.userName = _data["userName"];
            this.priorityId = _data["priorityId"];
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(item);
            }
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SinglePostDto {
        data = typeof data === 'object' ? data : {};
        let result = new SinglePostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["description"] = this.description;
        data["userName"] = this.userName;
        data["priorityId"] = this.priorityId;
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item);
        }
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface ISinglePostDto extends ILogInfo {
    id: number;
    header?: string | undefined;
    description?: string | undefined;
    userName?: string | undefined;
    priorityId: number;
    topics?: string[] | undefined;
    message?: string | undefined;
}

export class PostDescriptionDto extends LogInfo implements IPostDescriptionDto {
    id!: number;
    header?: string | undefined;
    description?: string | undefined;
    userName?: string | undefined;
    priorityId!: number;
    topicIds?: number[] | undefined;

    constructor(data?: IPostDescriptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.description = _data["description"];
            this.userName = _data["userName"];
            this.priorityId = _data["priorityId"];
            if (Array.isArray(_data["topicIds"])) {
                this.topicIds = [] as any;
                for (let item of _data["topicIds"])
                    this.topicIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PostDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["description"] = this.description;
        data["userName"] = this.userName;
        data["priorityId"] = this.priorityId;
        if (Array.isArray(this.topicIds)) {
            data["topicIds"] = [];
            for (let item of this.topicIds)
                data["topicIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPostDescriptionDto extends ILogInfo {
    id: number;
    header?: string | undefined;
    description?: string | undefined;
    userName?: string | undefined;
    priorityId: number;
    topicIds?: number[] | undefined;
}

export class AdditionalDto implements IAdditionalDto {
    topics?: TopicDto[] | undefined;
    priorities?: PriorityDto[] | undefined;
    videos?: string[] | undefined;
    videoFolderName?: string | undefined;

    constructor(data?: IAdditionalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(TopicDto.fromJS(item));
            }
            if (Array.isArray(_data["priorities"])) {
                this.priorities = [] as any;
                for (let item of _data["priorities"])
                    this.priorities!.push(PriorityDto.fromJS(item));
            }
            if (Array.isArray(_data["videos"])) {
                this.videos = [] as any;
                for (let item of _data["videos"])
                    this.videos!.push(item);
            }
            this.videoFolderName = _data["videoFolderName"];
        }
    }

    static fromJS(data: any): AdditionalDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item.toJSON());
        }
        if (Array.isArray(this.priorities)) {
            data["priorities"] = [];
            for (let item of this.priorities)
                data["priorities"].push(item.toJSON());
        }
        if (Array.isArray(this.videos)) {
            data["videos"] = [];
            for (let item of this.videos)
                data["videos"].push(item);
        }
        data["videoFolderName"] = this.videoFolderName;
        return data; 
    }
}

export interface IAdditionalDto {
    topics?: TopicDto[] | undefined;
    priorities?: PriorityDto[] | undefined;
    videos?: string[] | undefined;
    videoFolderName?: string | undefined;
}

export class TopicDto implements ITopicDto {
    id!: number;
    name?: string | undefined;

    constructor(data?: ITopicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TopicDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITopicDto {
    id: number;
    name?: string | undefined;
}

export class PriorityDto implements IPriorityDto {
    id!: number;
    name?: string | undefined;

    constructor(data?: IPriorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPriorityDto {
    id: number;
    name?: string | undefined;
}

export class PostWriteDto extends LogInfo implements IPostWriteDto {
    id!: number;
    header?: string | undefined;
    description?: string | undefined;
    userId!: number;
    topicIds?: number[] | undefined;
    priorityId!: number;
    message?: string | undefined;

    constructor(data?: IPostWriteDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.description = _data["description"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["topicIds"])) {
                this.topicIds = [] as any;
                for (let item of _data["topicIds"])
                    this.topicIds!.push(item);
            }
            this.priorityId = _data["priorityId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PostWriteDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostWriteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["description"] = this.description;
        data["userId"] = this.userId;
        if (Array.isArray(this.topicIds)) {
            data["topicIds"] = [];
            for (let item of this.topicIds)
                data["topicIds"].push(item);
        }
        data["priorityId"] = this.priorityId;
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IPostWriteDto extends ILogInfo {
    id: number;
    header?: string | undefined;
    description?: string | undefined;
    userId: number;
    topicIds?: number[] | undefined;
    priorityId: number;
    message?: string | undefined;
}

export class ChatAvailableUsersListDto implements IChatAvailableUsersListDto {
    active?: ChatAvailableUserDto[] | undefined;
    inactive?: ChatAvailableUserDto[] | undefined;

    constructor(data?: IChatAvailableUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["active"])) {
                this.active = [] as any;
                for (let item of _data["active"])
                    this.active!.push(ChatAvailableUserDto.fromJS(item));
            }
            if (Array.isArray(_data["inactive"])) {
                this.inactive = [] as any;
                for (let item of _data["inactive"])
                    this.inactive!.push(ChatAvailableUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatAvailableUsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatAvailableUsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.active)) {
            data["active"] = [];
            for (let item of this.active)
                data["active"].push(item.toJSON());
        }
        if (Array.isArray(this.inactive)) {
            data["inactive"] = [];
            for (let item of this.inactive)
                data["inactive"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChatAvailableUsersListDto {
    active?: ChatAvailableUserDto[] | undefined;
    inactive?: ChatAvailableUserDto[] | undefined;
}

export class ChatAvailableUserDto implements IChatAvailableUserDto {
    id!: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    signalRId?: string | undefined;

    constructor(data?: IChatAvailableUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.signalRId = _data["signalRId"];
        }
    }

    static fromJS(data: any): ChatAvailableUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatAvailableUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["signalRId"] = this.signalRId;
        return data; 
    }
}

export interface IChatAvailableUserDto {
    id: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    signalRId?: string | undefined;
}

export class UserMessageDto implements IUserMessageDto {
    id!: number;
    isMine!: boolean;
    message?: string | undefined;
    time!: Date;

    constructor(data?: IUserMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isMine = _data["isMine"];
            this.message = _data["message"];
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isMine"] = this.isMine;
        data["message"] = this.message;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserMessageDto {
    id: number;
    isMine: boolean;
    message?: string | undefined;
    time: Date;
}

export class BaseCaptchaViewModel implements IBaseCaptchaViewModel {
    captcha?: CaptchaCheckDto | undefined;

    constructor(data?: IBaseCaptchaViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.captcha = _data["captcha"] ? CaptchaCheckDto.fromJS(_data["captcha"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseCaptchaViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCaptchaViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captcha"] = this.captcha ? this.captcha.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseCaptchaViewModel {
    captcha?: CaptchaCheckDto | undefined;
}

export class PreseedSettingsViewModel extends BaseCaptchaViewModel implements IPreseedSettingsViewModel {
    mirror?: string | undefined;
    rootPassword?: string | undefined;
    userName?: string | undefined;
    userFullName?: string | undefined;
    userPassword?: string | undefined;
    additionalSoft?: string | undefined;
    imageConfig?: ImageConfig | undefined;
    currentArchitectures?: ArchitectureType[] | undefined;
    forceDownload!: boolean;
    hddSplitSettingsVM?: HddSplitSettingsViewModel | undefined;
    deviceType!: DeviceType;

    constructor(data?: IPreseedSettingsViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mirror = _data["mirror"];
            this.rootPassword = _data["rootPassword"];
            this.userName = _data["userName"];
            this.userFullName = _data["userFullName"];
            this.userPassword = _data["userPassword"];
            this.additionalSoft = _data["additionalSoft"];
            this.imageConfig = _data["imageConfig"] ? ImageConfig.fromJS(_data["imageConfig"]) : <any>undefined;
            if (Array.isArray(_data["currentArchitectures"])) {
                this.currentArchitectures = [] as any;
                for (let item of _data["currentArchitectures"])
                    this.currentArchitectures!.push(item);
            }
            this.forceDownload = _data["forceDownload"];
            this.hddSplitSettingsVM = _data["hddSplitSettingsVM"] ? HddSplitSettingsViewModel.fromJS(_data["hddSplitSettingsVM"]) : <any>undefined;
            this.deviceType = _data["deviceType"];
        }
    }

    static fromJS(data: any): PreseedSettingsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PreseedSettingsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mirror"] = this.mirror;
        data["rootPassword"] = this.rootPassword;
        data["userName"] = this.userName;
        data["userFullName"] = this.userFullName;
        data["userPassword"] = this.userPassword;
        data["additionalSoft"] = this.additionalSoft;
        data["imageConfig"] = this.imageConfig ? this.imageConfig.toJSON() : <any>undefined;
        if (Array.isArray(this.currentArchitectures)) {
            data["currentArchitectures"] = [];
            for (let item of this.currentArchitectures)
                data["currentArchitectures"].push(item);
        }
        data["forceDownload"] = this.forceDownload;
        data["hddSplitSettingsVM"] = this.hddSplitSettingsVM ? this.hddSplitSettingsVM.toJSON() : <any>undefined;
        data["deviceType"] = this.deviceType;
        super.toJSON(data);
        return data; 
    }
}

export interface IPreseedSettingsViewModel extends IBaseCaptchaViewModel {
    mirror?: string | undefined;
    rootPassword?: string | undefined;
    userName?: string | undefined;
    userFullName?: string | undefined;
    userPassword?: string | undefined;
    additionalSoft?: string | undefined;
    imageConfig?: ImageConfig | undefined;
    currentArchitectures?: ArchitectureType[] | undefined;
    forceDownload: boolean;
    hddSplitSettingsVM?: HddSplitSettingsViewModel | undefined;
    deviceType: DeviceType;
}

export class ImageConfig implements IImageConfig {
    name?: string | undefined;
    architectureType!: ArchitectureType;
    urlType!: UrlType;

    constructor(data?: IImageConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.architectureType = _data["architectureType"];
            this.urlType = _data["urlType"];
        }
    }

    static fromJS(data: any): ImageConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ImageConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["architectureType"] = this.architectureType;
        data["urlType"] = this.urlType;
        return data; 
    }
}

export interface IImageConfig {
    name?: string | undefined;
    architectureType: ArchitectureType;
    urlType: UrlType;
}

export enum ArchitectureType {
    Alpha = 0,
    Arm = 1,
    Hppa = 2,
    I386 = 3,
    Ia64 = 4,
    M68k = 5,
    Mips = 6,
    Mipsel = 7,
    Powerpc = 8,
    S390 = 9,
    Sparc = 10,
    Trace = 11,
    Amd64 = 12,
    Multi_arch = 13,
    Armel = 14,
    Kfreebsd_amd64 = 15,
    Kfreebsd_i386 = 16,
    Armhf = 17,
    S390x = 18,
    Arm64 = 19,
    Ppc64el = 20,
    Mips64el = 21,
}

export enum UrlType {
    Iso = 1,
    Hybrid = 2,
    Jigdo = 4,
}

export class HddSplitSettingsViewModel implements IHddSplitSettingsViewModel {
    configs?: PartitionConfig[] | undefined;

    constructor(data?: IHddSplitSettingsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["configs"])) {
                this.configs = [] as any;
                for (let item of _data["configs"])
                    this.configs!.push(PartitionConfig.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HddSplitSettingsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new HddSplitSettingsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.configs)) {
            data["configs"] = [];
            for (let item of this.configs)
                data["configs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHddSplitSettingsViewModel {
    configs?: PartitionConfig[] | undefined;
}

export class PartitionConfig implements IPartitionConfig {
    size!: number;
    partitionType!: PartitionType;
    fileSystemType!: FileSystemType;

    constructor(data?: IPartitionConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.size = _data["size"];
            this.partitionType = _data["partitionType"];
            this.fileSystemType = _data["fileSystemType"];
        }
    }

    static fromJS(data: any): PartitionConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PartitionConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["partitionType"] = this.partitionType;
        data["fileSystemType"] = this.fileSystemType;
        return data; 
    }
}

export interface IPartitionConfig {
    size: number;
    partitionType: PartitionType;
    fileSystemType: FileSystemType;
}

export enum PartitionType {
    Boot = 0,
    Swap = 1,
    Root = 2,
    Tmp = 3,
    Var = 4,
    Opt = 5,
    VarLog = 6,
    VarTmp = 7,
    Home = 8,
    RootPart = 9,
}

export enum FileSystemType {
    Swap = 0,
    Ext2 = 1,
    Ext3 = 2,
    Ext4 = 3,
    Jfs = 4,
    Xfs = 5,
    Reiserfs = 6,
    Btrfs = 7,
}

export enum DeviceType {
    CD = 1,
    USB = 2,
}

export class CaptchaCheckDto implements ICaptchaCheckDto {
    captcha?: string | undefined;
    hash?: string | undefined;

    constructor(data?: ICaptchaCheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.captcha = _data["captcha"];
            this.hash = _data["hash"];
        }
    }

    static fromJS(data: any): CaptchaCheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new CaptchaCheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captcha"] = this.captcha;
        data["hash"] = this.hash;
        return data; 
    }
}

export interface ICaptchaCheckDto {
    captcha?: string | undefined;
    hash?: string | undefined;
}

export class PagedDataViewModelOfFeedbackDto implements IPagedDataViewModelOfFeedbackDto {
    count!: number;
    data?: FeedbackDto[] | undefined;

    constructor(data?: IPagedDataViewModelOfFeedbackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FeedbackDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedDataViewModelOfFeedbackDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataViewModelOfFeedbackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedDataViewModelOfFeedbackDto {
    count: number;
    data?: FeedbackDto[] | undefined;
}

export class FeedbackDto implements IFeedbackDto {
    id!: number;
    topic?: string | undefined;
    details?: string | undefined;
    createdTime!: Date;
    isVisible!: boolean;
    email?: string | undefined;

    constructor(data?: IFeedbackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.topic = _data["topic"];
            this.details = _data["details"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.isVisible = _data["isVisible"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): FeedbackDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeedbackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["topic"] = this.topic;
        data["details"] = this.details;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["isVisible"] = this.isVisible;
        data["email"] = this.email;
        return data; 
    }
}

export interface IFeedbackDto {
    id: number;
    topic?: string | undefined;
    details?: string | undefined;
    createdTime: Date;
    isVisible: boolean;
    email?: string | undefined;
}

export class FeedbackQueryViewModel extends QueryViewModel implements IFeedbackQueryViewModel {

    constructor(data?: IFeedbackQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): FeedbackQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeedbackQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFeedbackQueryViewModel extends IQueryViewModel {
}

export class FeedbackInsertDto implements IFeedbackInsertDto {
    topic?: string | undefined;
    details?: string | undefined;
    isVisible!: boolean;

    constructor(data?: IFeedbackInsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.topic = _data["topic"];
            this.details = _data["details"];
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): FeedbackInsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeedbackInsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["topic"] = this.topic;
        data["details"] = this.details;
        data["isVisible"] = this.isVisible;
        return data; 
    }
}

export interface IFeedbackInsertDto {
    topic?: string | undefined;
    details?: string | undefined;
    isVisible: boolean;
}

export class LogBaseDto implements ILogBaseDto {
    time!: Date;
    userName?: string | undefined;
    ipAddress?: string | undefined;

    constructor(data?: ILogBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): LogBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["ipAddress"] = this.ipAddress;
        return data; 
    }
}

export interface ILogBaseDto {
    time: Date;
    userName?: string | undefined;
    ipAddress?: string | undefined;
}

export class LogDto extends LogBaseDto implements ILogDto {
    path?: string | undefined;

    constructor(data?: ILogDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): LogDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        super.toJSON(data);
        return data; 
    }
}

export interface ILogDto extends ILogBaseDto {
    path?: string | undefined;
}

export class ErrorLogDto extends LogBaseDto implements IErrorLogDto {
    message?: string | undefined;

    constructor(data?: IErrorLogDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IErrorLogDto extends ILogBaseDto {
    message?: string | undefined;
}

export class ImageParamsViewModel extends BaseCaptchaViewModel implements IImageParamsViewModel {
    base64!: string;

    constructor(data?: IImageParamsViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.base64 = _data["base64"];
        }
    }

    static fromJS(data: any): ImageParamsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImageParamsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64"] = this.base64;
        super.toJSON(data);
        return data; 
    }
}

export interface IImageParamsViewModel extends IBaseCaptchaViewModel {
    base64: string;
}

export class TypeHeaderDto implements ITypeHeaderDto {
    id!: number;
    name?: string | undefined;
    courses?: CourseHeaderDto[] | undefined;

    constructor(data?: ITypeHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["courses"])) {
                this.courses = [] as any;
                for (let item of _data["courses"])
                    this.courses!.push(CourseHeaderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new TypeHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.courses)) {
            data["courses"] = [];
            for (let item of this.courses)
                data["courses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITypeHeaderDto {
    id: number;
    name?: string | undefined;
    courses?: CourseHeaderDto[] | undefined;
}

export class CourseHeaderDto implements ICourseHeaderDto {
    id!: number;
    name?: string | undefined;
    author?: string | undefined;

    constructor(data?: ICourseHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.author = _data["author"];
        }
    }

    static fromJS(data: any): CourseHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["author"] = this.author;
        return data; 
    }
}

export interface ICourseHeaderDto {
    id: number;
    name?: string | undefined;
    author?: string | undefined;
}

export class CourseDto implements ICourseDto {
    id!: number;
    name?: string | undefined;
    description?: string | undefined;
    originalSite?: string | undefined;
    originalLink?: string | undefined;
    type?: string | undefined;
    author?: string | undefined;
    folders?: FolderDto[] | undefined;
    books?: BookDto[] | undefined;

    constructor(data?: ICourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.originalSite = _data["originalSite"];
            this.originalLink = _data["originalLink"];
            this.type = _data["type"];
            this.author = _data["author"];
            if (Array.isArray(_data["folders"])) {
                this.folders = [] as any;
                for (let item of _data["folders"])
                    this.folders!.push(FolderDto.fromJS(item));
            }
            if (Array.isArray(_data["books"])) {
                this.books = [] as any;
                for (let item of _data["books"])
                    this.books!.push(BookDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["originalSite"] = this.originalSite;
        data["originalLink"] = this.originalLink;
        data["type"] = this.type;
        data["author"] = this.author;
        if (Array.isArray(this.folders)) {
            data["folders"] = [];
            for (let item of this.folders)
                data["folders"].push(item.toJSON());
        }
        if (Array.isArray(this.books)) {
            data["books"] = [];
            for (let item of this.books)
                data["books"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICourseDto {
    id: number;
    name?: string | undefined;
    description?: string | undefined;
    originalSite?: string | undefined;
    originalLink?: string | undefined;
    type?: string | undefined;
    author?: string | undefined;
    folders?: FolderDto[] | undefined;
    books?: BookDto[] | undefined;
}

export class FolderDto implements IFolderDto {
    id!: number;
    courseId!: number;
    name?: string | undefined;
    path?: string | undefined;
    videos?: VideoDto[] | undefined;

    constructor(data?: IFolderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.name = _data["name"];
            this.path = _data["path"];
            if (Array.isArray(_data["videos"])) {
                this.videos = [] as any;
                for (let item of _data["videos"])
                    this.videos!.push(VideoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FolderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FolderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["name"] = this.name;
        data["path"] = this.path;
        if (Array.isArray(this.videos)) {
            data["videos"] = [];
            for (let item of this.videos)
                data["videos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFolderDto {
    id: number;
    courseId: number;
    name?: string | undefined;
    path?: string | undefined;
    videos?: VideoDto[] | undefined;
}

export class VideoDto implements IVideoDto {
    id!: number;
    name?: string | undefined;
    path?: string | undefined;
    description?: string | undefined;
    ext?: string | undefined;
    repeat!: number;

    constructor(data?: IVideoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.description = _data["description"];
            this.ext = _data["ext"];
            this.repeat = _data["repeat"];
        }
    }

    static fromJS(data: any): VideoDto {
        data = typeof data === 'object' ? data : {};
        let result = new VideoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["description"] = this.description;
        data["ext"] = this.ext;
        data["repeat"] = this.repeat;
        return data; 
    }
}

export interface IVideoDto {
    id: number;
    name?: string | undefined;
    path?: string | undefined;
    description?: string | undefined;
    ext?: string | undefined;
    repeat: number;
}

export class BookDto implements IBookDto {
    id!: number;
    name?: string | undefined;
    path?: string | undefined;
    fType?: string | undefined;

    constructor(data?: IBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.fType = _data["fType"];
        }
    }

    static fromJS(data: any): BookDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["fType"] = this.fType;
        return data; 
    }
}

export interface IBookDto {
    id: number;
    name?: string | undefined;
    path?: string | undefined;
    fType?: string | undefined;
}

export class StegSettingsDto implements IStegSettingsDto {
    fileName?: string | undefined;
    message?: string | undefined;
    colors?: number[] | undefined;
    mode!: string;
    startIndex!: number;
    step!: number;
    simple?: SimpleDto | undefined;
    func?: FuncDto | undefined;

    constructor(data?: IStegSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.message = _data["message"];
            if (Array.isArray(_data["colors"])) {
                this.colors = [] as any;
                for (let item of _data["colors"])
                    this.colors!.push(item);
            }
            this.mode = _data["mode"];
            this.startIndex = _data["startIndex"];
            this.step = _data["step"];
            this.simple = _data["simple"] ? SimpleDto.fromJS(_data["simple"]) : <any>undefined;
            this.func = _data["func"] ? FuncDto.fromJS(_data["func"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StegSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StegSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["message"] = this.message;
        if (Array.isArray(this.colors)) {
            data["colors"] = [];
            for (let item of this.colors)
                data["colors"].push(item);
        }
        data["mode"] = this.mode;
        data["startIndex"] = this.startIndex;
        data["step"] = this.step;
        data["simple"] = this.simple ? this.simple.toJSON() : <any>undefined;
        data["func"] = this.func ? this.func.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStegSettingsDto {
    fileName?: string | undefined;
    message?: string | undefined;
    colors?: number[] | undefined;
    mode: string;
    startIndex: number;
    step: number;
    simple?: SimpleDto | undefined;
    func?: FuncDto | undefined;
}

export class SimpleDto implements ISimpleDto {
    isHorizontal!: boolean;
    isInverted!: boolean;

    constructor(data?: ISimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isHorizontal = _data["isHorizontal"];
            this.isInverted = _data["isInverted"];
        }
    }

    static fromJS(data: any): SimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isHorizontal"] = this.isHorizontal;
        data["isInverted"] = this.isInverted;
        return data; 
    }
}

export interface ISimpleDto {
    isHorizontal: boolean;
    isInverted: boolean;
}

export class FuncDto implements IFuncDto {
    description?: string | undefined;

    constructor(data?: IFuncDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FuncDto {
        data = typeof data === 'object' ? data : {};
        let result = new FuncDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }
}

export interface IFuncDto {
    description?: string | undefined;
}

export class TimeStampDto implements ITimeStampDto {
    videoId!: number;
    userId!: number;
    seconds!: number;
    comment?: string | undefined;

    constructor(data?: ITimeStampDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.videoId = _data["videoId"];
            this.userId = _data["userId"];
            this.seconds = _data["seconds"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): TimeStampDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeStampDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["videoId"] = this.videoId;
        data["userId"] = this.userId;
        data["seconds"] = this.seconds;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ITimeStampDto {
    videoId: number;
    userId: number;
    seconds: number;
    comment?: string | undefined;
}

export class TimeStampUserDto extends TimeStampDto implements ITimeStampUserDto {
    userEmail?: string | undefined;

    constructor(data?: ITimeStampUserDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): TimeStampUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeStampUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail;
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeStampUserDto extends ITimeStampDto {
    userEmail?: string | undefined;
}

export class VideoStreamInfoViewModel implements IVideoStreamInfoViewModel {
    bitrate!: number;
    videoEncoding?: string | undefined;
    videoQualityLabel?: string | undefined;
    videoQuality?: string | undefined;
    resolution?: string | undefined;
    framerate!: number;

    constructor(data?: IVideoStreamInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bitrate = _data["bitrate"];
            this.videoEncoding = _data["videoEncoding"];
            this.videoQualityLabel = _data["videoQualityLabel"];
            this.videoQuality = _data["videoQuality"];
            this.resolution = _data["resolution"];
            this.framerate = _data["framerate"];
        }
    }

    static fromJS(data: any): VideoStreamInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VideoStreamInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitrate"] = this.bitrate;
        data["videoEncoding"] = this.videoEncoding;
        data["videoQualityLabel"] = this.videoQualityLabel;
        data["videoQuality"] = this.videoQuality;
        data["resolution"] = this.resolution;
        data["framerate"] = this.framerate;
        return data; 
    }
}

export interface IVideoStreamInfoViewModel {
    bitrate: number;
    videoEncoding?: string | undefined;
    videoQualityLabel?: string | undefined;
    videoQuality?: string | undefined;
    resolution?: string | undefined;
    framerate: number;
}

export class LoginViewModel implements ILoginViewModel {
    email!: string;
    password!: string;
    rememberMe!: boolean;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ILoginViewModel {
    email: string;
    password: string;
    rememberMe: boolean;
}

export class RegisterViewModel extends BaseCaptchaViewModel implements IRegisterViewModel {
    username?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    email!: string;
    password!: string;
    mobile?: string | undefined;

    constructor(data?: IRegisterViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.username = _data["username"];
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.mobile = _data["mobile"];
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["email"] = this.email;
        data["password"] = this.password;
        data["mobile"] = this.mobile;
        super.toJSON(data);
        return data; 
    }
}

export interface IRegisterViewModel extends IBaseCaptchaViewModel {
    username?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    email: string;
    password: string;
    mobile?: string | undefined;
}

export class ForgotPasswordViewModel implements IForgotPasswordViewModel {
    email!: string;

    constructor(data?: IForgotPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IForgotPasswordViewModel {
    email: string;
}

export class ResetPasswordViewModel implements IResetPasswordViewModel {
    email!: string;
    password!: string;
    confirmPassword?: string | undefined;
    code?: string | undefined;

    constructor(data?: IResetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ResetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["code"] = this.code;
        return data; 
    }
}

export interface IResetPasswordViewModel {
    email: string;
    password: string;
    confirmPassword?: string | undefined;
    code?: string | undefined;
}

export class SendCodeViewModel implements ISendCodeViewModel {
    selectedProvider?: string | undefined;
    providers?: SelectListItem[] | undefined;
    returnUrl?: string | undefined;
    rememberMe!: boolean;

    constructor(data?: ISendCodeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.selectedProvider = _data["selectedProvider"];
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(SelectListItem.fromJS(item));
            }
            this.returnUrl = _data["returnUrl"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): SendCodeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendCodeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["selectedProvider"] = this.selectedProvider;
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item.toJSON());
        }
        data["returnUrl"] = this.returnUrl;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ISendCodeViewModel {
    selectedProvider?: string | undefined;
    providers?: SelectListItem[] | undefined;
    returnUrl?: string | undefined;
    rememberMe: boolean;
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group?: SelectListGroup | undefined;
    selected!: boolean;
    text?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group?: SelectListGroup | undefined;
    selected: boolean;
    text?: string | undefined;
    value?: string | undefined;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name?: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name?: string | undefined;
}

export class CaptchaDto implements ICaptchaDto {
    name?: string | undefined;
    hash?: string | undefined;

    constructor(data?: ICaptchaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.hash = _data["hash"];
        }
    }

    static fromJS(data: any): CaptchaDto {
        data = typeof data === 'object' ? data : {};
        let result = new CaptchaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["hash"] = this.hash;
        return data; 
    }
}

export interface ICaptchaDto {
    name?: string | undefined;
    hash?: string | undefined;
}

export class MessageTransferredDto implements IMessageTransferredDto {
    fromUserId!: number;
    toUserSignalRId?: string | undefined;
    fromUserName?: string | undefined;
    message?: string | undefined;

    constructor(data?: IMessageTransferredDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromUserId = _data["fromUserId"];
            this.toUserSignalRId = _data["toUserSignalRId"];
            this.fromUserName = _data["fromUserName"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): MessageTransferredDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageTransferredDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromUserId"] = this.fromUserId;
        data["toUserSignalRId"] = this.toUserSignalRId;
        data["fromUserName"] = this.fromUserName;
        data["message"] = this.message;
        return data; 
    }
}

export interface IMessageTransferredDto {
    fromUserId: number;
    toUserSignalRId?: string | undefined;
    fromUserName?: string | undefined;
    message?: string | undefined;
}

export class IndexViewModel implements IIndexViewModel {
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    isEmailConfirmed!: boolean;
    email?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IIndexViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): IndexViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new IndexViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IIndexViewModel {
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    isEmailConfirmed: boolean;
    email?: string | undefined;
    phoneNumber?: string | undefined;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    oldPassword!: string;
    newPassword!: string;
    confirmPassword?: string | undefined;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IChangePasswordViewModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
}

export class SetPasswordViewModel implements ISetPasswordViewModel {
    newPassword!: string;
    confirmPassword?: string | undefined;

    constructor(data?: ISetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): SetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface ISetPasswordViewModel {
    newPassword: string;
    confirmPassword?: string | undefined;
}

export class IdentityUserOfLong implements IIdentityUserOfLong {
    id!: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed!: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled!: boolean;
    accessFailedCount!: number;

    constructor(data?: IIdentityUserOfLong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfLong {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data; 
    }
}

export interface IIdentityUserOfLong {
    id: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

export class ApplicationUser extends IdentityUserOfLong implements IApplicationUser {
    isEnabled!: boolean;
    createdDate!: Date;
    firstName?: string | undefined;
    lastName?: string | undefined;
    mobile?: string | undefined;
    signalRId?: string | undefined;
    appId?: number | undefined;
    applicationUserPhotoId?: number | undefined;
    profilePhoto?: ApplicationUserPhoto | undefined;
    name?: string | undefined;
    results?: Result[] | undefined;

    constructor(data?: IApplicationUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.signalRId = _data["signalRId"];
            this.appId = _data["appId"];
            this.applicationUserPhotoId = _data["applicationUserPhotoId"];
            this.profilePhoto = _data["profilePhoto"] ? ApplicationUserPhoto.fromJS(_data["profilePhoto"]) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Result.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["signalRId"] = this.signalRId;
        data["appId"] = this.appId;
        data["applicationUserPhotoId"] = this.applicationUserPhotoId;
        data["profilePhoto"] = this.profilePhoto ? this.profilePhoto.toJSON() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IApplicationUser extends IIdentityUserOfLong {
    isEnabled: boolean;
    createdDate: Date;
    firstName?: string | undefined;
    lastName?: string | undefined;
    mobile?: string | undefined;
    signalRId?: string | undefined;
    appId?: number | undefined;
    applicationUserPhotoId?: number | undefined;
    profilePhoto?: ApplicationUserPhoto | undefined;
    name?: string | undefined;
    results?: Result[] | undefined;
}

export class ApplicationUserPhoto implements IApplicationUserPhoto {
    id!: number;
    contentType?: string | undefined;
    content?: string | undefined;
    applicationUserId!: number;
    applicationUser?: ApplicationUser | undefined;

    constructor(data?: IApplicationUserPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contentType = _data["contentType"];
            this.content = _data["content"];
            this.applicationUserId = _data["applicationUserId"];
            this.applicationUser = _data["applicationUser"] ? ApplicationUser.fromJS(_data["applicationUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserPhoto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserPhoto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contentType"] = this.contentType;
        data["content"] = this.content;
        data["applicationUserId"] = this.applicationUserId;
        data["applicationUser"] = this.applicationUser ? this.applicationUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApplicationUserPhoto {
    id: number;
    contentType?: string | undefined;
    content?: string | undefined;
    applicationUserId: number;
    applicationUser?: ApplicationUser | undefined;
}

export class ResultBase implements IResultBase {
    started!: Date;
    finished?: Date | undefined;
    timeSpentMiliSeconds?: number | undefined;
    isStarted!: boolean;
    isCompleted!: boolean;

    constructor(data?: IResultBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.timeSpentMiliSeconds = _data["timeSpentMiliSeconds"];
            this.isStarted = _data["isStarted"];
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): ResultBase {
        data = typeof data === 'object' ? data : {};
        let result = new ResultBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["timeSpentMiliSeconds"] = this.timeSpentMiliSeconds;
        data["isStarted"] = this.isStarted;
        data["isCompleted"] = this.isCompleted;
        return data; 
    }
}

export interface IResultBase {
    started: Date;
    finished?: Date | undefined;
    timeSpentMiliSeconds?: number | undefined;
    isStarted: boolean;
    isCompleted: boolean;
}

export class Result extends ResultBase implements IResult {
    id!: number;
    userId!: number;
    textId?: string | undefined;
    resultsEncodedString?: boolean[] | undefined;
    mode!: string;
    user?: ApplicationUser | undefined;
    errorForJoined?: ErrorForJoined[] | undefined;
    errorsForSeparated?: ErrorForSeparated[] | undefined;

    constructor(data?: IResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.textId = _data["textId"];
            if (Array.isArray(_data["resultsEncodedString"])) {
                this.resultsEncodedString = [] as any;
                for (let item of _data["resultsEncodedString"])
                    this.resultsEncodedString!.push(item);
            }
            this.mode = _data["mode"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["errorForJoined"])) {
                this.errorForJoined = [] as any;
                for (let item of _data["errorForJoined"])
                    this.errorForJoined!.push(ErrorForJoined.fromJS(item));
            }
            if (Array.isArray(_data["errorsForSeparated"])) {
                this.errorsForSeparated = [] as any;
                for (let item of _data["errorsForSeparated"])
                    this.errorsForSeparated!.push(ErrorForSeparated.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["textId"] = this.textId;
        if (Array.isArray(this.resultsEncodedString)) {
            data["resultsEncodedString"] = [];
            for (let item of this.resultsEncodedString)
                data["resultsEncodedString"].push(item);
        }
        data["mode"] = this.mode;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.errorForJoined)) {
            data["errorForJoined"] = [];
            for (let item of this.errorForJoined)
                data["errorForJoined"].push(item.toJSON());
        }
        if (Array.isArray(this.errorsForSeparated)) {
            data["errorsForSeparated"] = [];
            for (let item of this.errorsForSeparated)
                data["errorsForSeparated"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IResult extends IResultBase {
    id: number;
    userId: number;
    textId?: string | undefined;
    resultsEncodedString?: boolean[] | undefined;
    mode: string;
    user?: ApplicationUser | undefined;
    errorForJoined?: ErrorForJoined[] | undefined;
    errorsForSeparated?: ErrorForSeparated[] | undefined;
}

export class ErrorForJoined implements IErrorForJoined {
    id!: number;
    resultId!: number;
    errorValue?: string | undefined;
    result?: Result | undefined;

    constructor(data?: IErrorForJoined) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resultId = _data["resultId"];
            this.errorValue = _data["errorValue"];
            this.result = _data["result"] ? Result.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ErrorForJoined {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorForJoined();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resultId"] = this.resultId;
        data["errorValue"] = this.errorValue;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IErrorForJoined {
    id: number;
    resultId: number;
    errorValue?: string | undefined;
    result?: Result | undefined;
}

export class ErrorForSeparated implements IErrorForSeparated {
    id!: number;
    resultId!: number;
    paragraphIndex!: number;
    wordIndex!: number;
    errorValue?: string | undefined;
    result?: Result | undefined;

    constructor(data?: IErrorForSeparated) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resultId = _data["resultId"];
            this.paragraphIndex = _data["paragraphIndex"];
            this.wordIndex = _data["wordIndex"];
            this.errorValue = _data["errorValue"];
            this.result = _data["result"] ? Result.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ErrorForSeparated {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorForSeparated();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resultId"] = this.resultId;
        data["paragraphIndex"] = this.paragraphIndex;
        data["wordIndex"] = this.wordIndex;
        data["errorValue"] = this.errorValue;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IErrorForSeparated {
    id: number;
    resultId: number;
    paragraphIndex: number;
    wordIndex: number;
    errorValue?: string | undefined;
    result?: Result | undefined;
}

export class RemoveLoginViewModel implements IRemoveLoginViewModel {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;

    constructor(data?: IRemoveLoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): RemoveLoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveLoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data; 
    }
}

export interface IRemoveLoginViewModel {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
}

export class EnableAuthenticatorViewModel implements IEnableAuthenticatorViewModel {
    code!: string;
    readonly sharedKey?: string | undefined;
    authenticatorUri?: string | undefined;

    constructor(data?: IEnableAuthenticatorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            (<any>this).sharedKey = _data["sharedKey"];
            this.authenticatorUri = _data["authenticatorUri"];
        }
    }

    static fromJS(data: any): EnableAuthenticatorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new EnableAuthenticatorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["sharedKey"] = this.sharedKey;
        data["authenticatorUri"] = this.authenticatorUri;
        return data; 
    }
}

export interface IEnableAuthenticatorViewModel {
    code: string;
    sharedKey?: string | undefined;
    authenticatorUri?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}